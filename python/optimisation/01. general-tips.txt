1. Use real data for profiling
2. Turn off anti-virus if any
3. Keep test suite ready to check the correctness of code after optimization
4. Performance Metrics:
    - Measuring time :
        - 'time' and 'timeit' module : Includes sleep time
        - 'monotonic' and 'perf_counter' : high resolution timers
    - Memory management:
        - 'tracemalloc' library is used to understand memory allocations
        - 'memory_profiler' : External library for memory profiling
            - `python -m memory_profiler file.py`
        - `mprof` : generates profile data over time
            - `mprof run file.py` : It will generate *.dat output file
            - `mprof plot outputfile.dat` : Display memory usage as a graph
5. CPU Profilers : 
    - cProfile : Deterministic Profiler
        - Records every function call, returne and exceptions 
    - Documentation : https://docs.python.org/3/library/profile.html
    - `python -m cProfile <file>.py` : to generate profiling info for given file.py
    - `python -m pstat prof.out` :
        - pstat is tool to read the profiling output
        - prof.oout is the output file generated by cProfile
        - Above command will open an interactive shell to check the stats
    - Other profile output reader is 'SnakeViz'
6. Line Profilers:
    - pip install line_profiler
    - @profile decorator to indicate the part of code to profile
    - `kernprof -l prof.py` : run line profiling on file 'prof.py'
    - It will generate *.lprof output file
    - `python -m line_profiler <profoutput>.lprof` : Display the line profiling output line by line
7. Check assembly code in python : 'dis' module
8. Use CPython